#define LOG_OUT 1 // use the log output function
#define FHT_N 256 // set to 256 point fht
#define DELAY_ANCHO_BANDA 74  //74 para B.W=6400Hz y Res=50Hz.   75 para simulacion Proteus

//Constantes de Filtros
#define UMBRAL_FILTRO_FUNDAMENTAL 85
#define UMBRAL_FILTRO_SOBRETONO 54 //60
#define FILTRO_REPETICION_NOTAS 4         //Para desactivar, asignar 1
#define FILTRO_REPETICION_RESET 8         //Al alcanzar este valor de repeticion de NOTAS_INDEFINIDAS, el contador de notas se resetea (cuanto mas alto, mas permisivo). Para desactivar asignar 255 como max.
#define CONDICION_MAXIMO_FUNDAMENTAL 20   //Para desactivar, asignar 1
#define CONDICION_MAXIMO_SOBRETONO 20     //Para desactivar, asignar 1

#include <FHT.h> // include the library

bool mEstado = LOW;
enum Id_Nota_t{NOTA_INDEFINIDA, C2, D2, E2, F2, G3 };

struct Nota_t{
    Id_Nota_t Id;
    uint8_t F0;
    uint8_t F1;
};

//Ingreso Frecuencia Fundamental / Resolucion
#define CANTIDAD_NOTAS 5
Nota_t mNotas[CANTIDAD_NOTAS] = {
   {C2, 2050/50, 5550/50},
   {D2, 2300/50, 6200/50},
   {E2, 2600/50, 5800/50},
   {F2, 2750/50, 3200/50},
   {G3, 3100/50, 3500/50}
};


void InicializarMicrofono(){
  ADCSRA = 0xe5; // set the adc to free running mode
  ADMUX = 0x45; // use adc5
  DIDR0 = 0x01; // turn off the digital input for adc0
}


//Retorna la nota que reconoci贸. Devuelve 0 si no reconoci贸 ninguna.
uint8_t EscucharNotas(){
  EjecutarFFT();
  uint8_t nota_escuchada = BuscarNotas();
  
  switch(nota_escuchada){
    case C2: Serial.println("#C2"); break;
    case D2: Serial.println("#D2"); break;
    case E2: Serial.println("#E2"); break;
    case F2: Serial.println("#F2"); break;
    case G3: Serial.println("#G3"); break;
  }

  return nota_escuchada;
}


void EjecutarFFT() {
  TIMSK0 = 0; // turn off timer0 for lower jitter
  cli();  // UDRE interrupt slows this way down on arduino1.0
  for (int i = 0 ; i < FHT_N ; i++) { // save 256 samples
    while(!(ADCSRA & 0x10)); // wait for adc to be ready
    ADCSRA = 0xf5; // restart adc
    byte m = ADCL; // fetch adc data
    byte j = ADCH;
    int k = (j << 8) | m; // form into an int
    k -= 0x0200; // form into a signed int
    k <<= 6; // form into a 16b signed int
    fht_input[i] = k; // put real data into bins
    delayMicroseconds(DELAY_ANCHO_BANDA);      //
  }
  
  fht_window(); // window the data for better frequency response
  fht_reorder(); // reorder the data before doing the fht
  fht_run(); // process the data in the fht
  fht_mag_log(); // take the output of the fht
  sei();
  uint8_t numero;
  if (g_modo == ANALIZADOR){
    Serial.write(fht_log_out, FHT_N/2);   // Send out the data.
    Serial.write(255);
  }
  TIMSK0 = 1; // Activo nuevamente el Timer0

  if (mEstado == LOW){
    mEstado = HIGH;
    digitalWrite(A0, HIGH);
  }
  else {
    mEstado = LOW;
    digitalWrite(A0, LOW);
  }
}


Id_Nota_t mIdNotaAnterior = NOTA_INDEFINIDA;
uint8_t mRepeticionesNotas = 1;
uint8_t mRepeticionesNotaIndefinida = 1;


uint8_t BuscarNotas() {  
  Id_Nota_t notaEncontrada = NOTA_INDEFINIDA;

  for (int i=0; i<CANTIDAD_NOTAS; i++)
  {
      if (FrecuenciaEsMaximo(mNotas[i].F0, UMBRAL_FILTRO_FUNDAMENTAL) &&
          FrecuenciaEsMaximo(mNotas[i].F1, UMBRAL_FILTRO_SOBRETONO))
      {
        switch(mNotas[i].Id){
          case C2: Serial.println("C2"); break;
          case D2: Serial.println("D2"); break;
          case E2: Serial.println("E2"); break;
          case F2: Serial.println("F2"); break;
          case G3: Serial.println("G3"); break;
        }
        mRepeticionesNotaIndefinida = 0;
        
        if (mNotas[i].Id == mIdNotaAnterior)
          mRepeticionesNotas++;
        else
          mRepeticionesNotas = 1;

        //Si se repitio el nro suficiente de veces, la doy como buena.
        if (mRepeticionesNotas == FILTRO_REPETICION_NOTAS){
          notaEncontrada = mNotas[i].Id;
          mRepeticionesNotas = 0;
        }

        mIdNotaAnterior = mNotas[i].Id;
        break;
      }
  }

  //Si no se indentifico ninguna nota
  if (notaEncontrada == NOTA_INDEFINIDA) {
    mRepeticionesNotaIndefinida++;
    if (mRepeticionesNotaIndefinida == FILTRO_REPETICION_RESET){
      mIdNotaAnterior = NOTA_INDEFINIDA;
      mRepeticionesNotaIndefinida = 0;
      mRepeticionesNotas = 0;
    }
  }
  return notaEncontrada;
}


bool FrecuenciaEsMaximo(uint8_t frecuencia, uint8_t umbralDeteccion) {

  uint8_t valor_actual    = fht_log_out[frecuencia];
  uint8_t valor_anterior  = fht_log_out[frecuencia-1];
  uint8_t valor_posterior = fht_log_out[frecuencia+1];  
  uint8_t valor_ante_anterior = fht_log_out[frecuencia-2];
  uint8_t valor_pos_posterior = fht_log_out[frecuencia+2];
  boolean es_maximo = false;
  
  if (valor_actual < umbralDeteccion) return false;

  //Primera condici贸n de Maximo.
  if ((valor_actual > valor_anterior) && (valor_actual > valor_posterior)){
    if ( valor_actual >= valor_ante_anterior + CONDICION_MAXIMO_FUNDAMENTAL &&
         valor_actual >= valor_pos_posterior + CONDICION_MAXIMO_FUNDAMENTAL){
      es_maximo = true;        
    }
    else
      es_maximo = false;
  }

  //2da condici贸n de maximos. Contempla las "puntas cuadradas" que no son captadas por la otra condicion
  if (valor_actual == valor_anterior && valor_actual > valor_posterior) 
    es_maximo = true;  

  return es_maximo;    
}

